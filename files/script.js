const WIDTH = 800;
const HEIGHT = (WIDTH * 9) / 16;
const nodes = [
  [0.4 * WIDTH, 0.5 * HEIGHT],
  [0.6 * WIDTH, 0.5 * HEIGHT],
];
const edges = [[1], []];
const vis = [0, 0];
const imp = [0.5, 0.5];
let nodeCount = 2;
let selNode = -1;
let visSum = 0;
let pos = 0;

function drawArrow(x1, y1, x2, y2) {
  // generated by Sonnet 4.5
  stroke(0);
  strokeWeight(2);
  line(x1, y1, x2, y2);

  push();
  translate(x2, y2);
  let angle = atan2(y2 - y1, x2 - x1);
  rotate(angle);
  fill(0);
  noStroke();
  triangle(0, 0, -20, -9, -20, 9);
  pop();
}

function addNode(x, y) {
  nodes.push([x, y]);
  edges.push([]);
  nodeCount++;

  for (let i = 0; i < nodeCount - 1; i++) {
    vis[i] = 1;
    imp[i] = 1 / nodeCount;
  }
  vis.push(1);
  imp.push(1 / nodeCount);
  visSum = nodeCount;
}

function addEdge(a, b) {
  edges[a].push(b);
  for (let i = 0; i < nodeCount; i++) vis[i] = 1;
  visSum = nodeCount;
}

function maxVis() {
  let res = 0;
  vis.forEach((x) => {
    res = res > x ? res : x;
  });
  return res;
}

function minVis() {
  let res = maxVis();
  vis.forEach((x) => {
    res = res < x ? res : x;
  });
  return res;
}

function mousePressed() {
  for (let i = 0; i < nodeCount; i++) {
    if ((nodes[i][0] - mouseX) ** 2 + (nodes[i][1] - mouseY) ** 2 <= 300) {
      if (selNode === -1) selNode = i;
      else if (selNode === i) selNode = -1;
      else {
        addEdge(selNode, i);
        selNode = -1;
      }
      return;
    }
  }

  if (selNode === -1) addNode(mouseX, mouseY);
  else selNode = -1;
}

function keyPressed() {
  if (key === "r") {
    for (let i = 0; i < nodeCount; i++) vis[i] = 1;
    visSum = nodeCount;
  }
}

function setup() {
  createCanvas(WIDTH, HEIGHT);
  background(240);
  setInterval(() => {
    console.log(vis);
    console.log(imp);
  }, 1000);
}

function draw() {
  // 간선 그리기
  for (let i = 0; i < nodeCount; i++) {
    edges[i].forEach((j) => {
      drawArrow(nodes[i][0], nodes[i][1], nodes[j][0], nodes[j][1]);
    });
  }

  // 정점 그리기
  for (let i = 0; i < nodeCount; i++) {
    stroke(
      i === selNode ? 255 : 0,
      i === selNode ? 0 : 128,
      i === selNode ? 0 : 255
    );
    strokeWeight(3);
    fill(127 + 128 * (1 - imp[i]), 255 * (1 - imp[i]), 0);
    circle(nodes[i][0], nodes[i][1], 18);
  }

  // 랜덤 서퍼 트릭
  if (nodeCount > 0) {
    for (let i = 0; i < 200; i++) {
      if (edges[pos].length === 0) pos = Math.floor(Math.random() * nodeCount);
      else if (Math.random() < 0.1) pos = Math.floor(Math.random() * nodeCount);
      else pos = edges[pos][Math.floor(Math.random() * edges[pos].length)];
      vis[pos]++;
      visSum++;
    }
    for (let i = 0; i < nodeCount; i++) {
      if (maxVis() != minVis())
        imp[i] = (vis[i] - minVis()) / (maxVis() - minVis());
      else imp[i] = 0.5;
    }
  }
}
